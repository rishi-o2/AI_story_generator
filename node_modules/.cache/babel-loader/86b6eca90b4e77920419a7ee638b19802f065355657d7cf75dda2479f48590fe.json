{"ast":null,"code":"import _defineProperty from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncToGenerator from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _awaitAsyncGenerator from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"E:/Chat_bot_intership/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nexport var Stream = /*#__PURE__*/function (_Symbol$asyncIterator) {\n  function Stream(response, controller) {\n    _classCallCheck(this, Stream);\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n  _createClass(Stream, [{\n    key: \"iterMessages\",\n    value: function iterMessages() {\n      var _this = this;\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var lineDecoder, iter, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, _iterator3, _step3, line, sse, _iterator4, _step4, _line, _sse;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (_this.response.body) {\n                _context.next = 3;\n                break;\n              }\n              _this.controller.abort();\n              throw new Error(\"Attempted to iterate over a response with no body\");\n            case 3:\n              lineDecoder = new LineDecoder();\n              iter = readableStreamAsyncIterable(_this.response.body);\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 7;\n              _iterator = _asyncIterator(iter);\n            case 9:\n              _context.next = 11;\n              return _awaitAsyncGenerator(_iterator.next());\n            case 11:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 35;\n                break;\n              }\n              chunk = _step.value;\n              _iterator3 = _createForOfIteratorHelper(lineDecoder.decode(chunk));\n              _context.prev = 14;\n              _iterator3.s();\n            case 16:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 24;\n                break;\n              }\n              line = _step3.value;\n              sse = _this.decoder.decode(line);\n              if (!sse) {\n                _context.next = 22;\n                break;\n              }\n              _context.next = 22;\n              return sse;\n            case 22:\n              _context.next = 16;\n              break;\n            case 24:\n              _context.next = 29;\n              break;\n            case 26:\n              _context.prev = 26;\n              _context.t0 = _context[\"catch\"](14);\n              _iterator3.e(_context.t0);\n            case 29:\n              _context.prev = 29;\n              _iterator3.f();\n              return _context.finish(29);\n            case 32:\n              _iteratorAbruptCompletion = false;\n              _context.next = 9;\n              break;\n            case 35:\n              _context.next = 41;\n              break;\n            case 37:\n              _context.prev = 37;\n              _context.t1 = _context[\"catch\"](7);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n            case 41:\n              _context.prev = 41;\n              _context.prev = 42;\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 46;\n                break;\n              }\n              _context.next = 46;\n              return _awaitAsyncGenerator(_iterator.return());\n            case 46:\n              _context.prev = 46;\n              if (!_didIteratorError) {\n                _context.next = 49;\n                break;\n              }\n              throw _iteratorError;\n            case 49:\n              return _context.finish(46);\n            case 50:\n              return _context.finish(41);\n            case 51:\n              _iterator4 = _createForOfIteratorHelper(lineDecoder.flush());\n              _context.prev = 52;\n              _iterator4.s();\n            case 54:\n              if ((_step4 = _iterator4.n()).done) {\n                _context.next = 62;\n                break;\n              }\n              _line = _step4.value;\n              _sse = _this.decoder.decode(_line);\n              if (!_sse) {\n                _context.next = 60;\n                break;\n              }\n              _context.next = 60;\n              return _sse;\n            case 60:\n              _context.next = 54;\n              break;\n            case 62:\n              _context.next = 67;\n              break;\n            case 64:\n              _context.prev = 64;\n              _context.t2 = _context[\"catch\"](52);\n              _iterator4.e(_context.t2);\n            case 67:\n              _context.prev = 67;\n              _iterator4.f();\n              return _context.finish(67);\n            case 70:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[7, 37, 41, 51], [14, 26, 29, 32], [42,, 46, 50], [52, 64, 67, 70]]);\n      }))();\n    }\n  }, {\n    key: _Symbol$asyncIterator,\n    value: function value() {\n      var _this2 = this;\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var done, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, sse;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              done = false;\n              _context2.prev = 1;\n              _iteratorAbruptCompletion2 = false;\n              _didIteratorError2 = false;\n              _context2.prev = 4;\n              _iterator2 = _asyncIterator(_this2.iterMessages());\n            case 6:\n              _context2.next = 8;\n              return _awaitAsyncGenerator(_iterator2.next());\n            case 8:\n              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context2.sent).done)) {\n                _context2.next = 29;\n                break;\n              }\n              sse = _step2.value;\n              if (!done) {\n                _context2.next = 12;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 26);\n            case 12:\n              if (!sse.data.startsWith('[DONE]')) {\n                _context2.next = 15;\n                break;\n              }\n              done = true;\n              return _context2.abrupt(\"continue\", 26);\n            case 15:\n              if (!(sse.event === null)) {\n                _context2.next = 26;\n                break;\n              }\n              _context2.prev = 16;\n              _context2.next = 19;\n              return JSON.parse(sse.data);\n            case 19:\n              _context2.next = 26;\n              break;\n            case 21:\n              _context2.prev = 21;\n              _context2.t0 = _context2[\"catch\"](16);\n              console.error(\"Could not parse message into JSON:\", sse.data);\n              console.error(\"From chunk:\", sse.raw);\n              throw _context2.t0;\n            case 26:\n              _iteratorAbruptCompletion2 = false;\n              _context2.next = 6;\n              break;\n            case 29:\n              _context2.next = 35;\n              break;\n            case 31:\n              _context2.prev = 31;\n              _context2.t1 = _context2[\"catch\"](4);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context2.t1;\n            case 35:\n              _context2.prev = 35;\n              _context2.prev = 36;\n              if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {\n                _context2.next = 40;\n                break;\n              }\n              _context2.next = 40;\n              return _awaitAsyncGenerator(_iterator2.return());\n            case 40:\n              _context2.prev = 40;\n              if (!_didIteratorError2) {\n                _context2.next = 43;\n                break;\n              }\n              throw _iteratorError2;\n            case 43:\n              return _context2.finish(40);\n            case 44:\n              return _context2.finish(35);\n            case 45:\n              done = true;\n              _context2.next = 53;\n              break;\n            case 48:\n              _context2.prev = 48;\n              _context2.t2 = _context2[\"catch\"](1);\n              if (!(_context2.t2 instanceof Error && _context2.t2.name === 'AbortError')) {\n                _context2.next = 52;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 52:\n              throw _context2.t2;\n            case 53:\n              _context2.prev = 53;\n              // If the user `break`s, abort the ongoing request.\n              if (!done) _this2.controller.abort();\n              return _context2.finish(53);\n            case 56:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[1, 48, 53, 56], [4, 31, 35, 45], [16, 21], [36,, 40, 44]]);\n      }))();\n    }\n  }]);\n  return Stream;\n}(Symbol.asyncIterator);\nvar SSEDecoder = /*#__PURE__*/function () {\n  function SSEDecoder() {\n    _classCallCheck(this, SSEDecoder);\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  _createClass(SSEDecoder, [{\n    key: \"decode\",\n    value: function decode(line) {\n      if (line.endsWith('\\r')) {\n        line = line.substring(0, line.length - 1);\n      }\n      if (!line) {\n        // empty line and we didn't previously encounter any messages\n        if (!this.event && !this.data.length) return null;\n        var sse = {\n          event: this.event,\n          data: this.data.join('\\n'),\n          raw: this.chunks\n        };\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n        return sse;\n      }\n      this.chunks.push(line);\n      if (line.startsWith(':')) {\n        return null;\n      }\n      var _partition = partition(line, ':'),\n        _partition2 = _slicedToArray(_partition, 3),\n        fieldname = _partition2[0],\n        _ = _partition2[1],\n        value = _partition2[2];\n      if (value.startsWith(' ')) {\n        value = value.substring(1);\n      }\n      if (fieldname === 'event') {\n        this.event = value;\n      } else if (fieldname === 'data') {\n        this.data.push(value);\n      }\n      return null;\n    }\n  }]);\n  return SSEDecoder;\n}();\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nvar LineDecoder = /*#__PURE__*/function () {\n  function LineDecoder() {\n    _classCallCheck(this, LineDecoder);\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n  _createClass(LineDecoder, [{\n    key: \"decode\",\n    value: function decode(chunk) {\n      var text = this.decodeText(chunk);\n      if (this.trailingCR) {\n        text = '\\r' + text;\n        this.trailingCR = false;\n      }\n      if (text.endsWith('\\r')) {\n        this.trailingCR = true;\n        text = text.slice(0, -1);\n      }\n      if (!text) {\n        return [];\n      }\n      var trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n      var lines = text.split(LineDecoder.NEWLINE_REGEXP);\n      if (lines.length === 1 && !trailingNewline) {\n        this.buffer.push(lines[0]);\n        return [];\n      }\n      if (this.buffer.length > 0) {\n        lines = [this.buffer.join('') + lines[0]].concat(_toConsumableArray(lines.slice(1)));\n        this.buffer = [];\n      }\n      if (!trailingNewline) {\n        this.buffer = [lines.pop() || ''];\n      }\n      return lines;\n    }\n  }, {\n    key: \"decodeText\",\n    value: function decodeText(bytes) {\n      var _a;\n      if (bytes == null) return '';\n      if (typeof bytes === 'string') return bytes;\n      // Node:\n      if (typeof Buffer !== 'undefined') {\n        if (bytes instanceof Buffer) {\n          return bytes.toString();\n        }\n        if (bytes instanceof Uint8Array) {\n          return Buffer.from(bytes).toString();\n        }\n        throw new Error(\"Unexpected: received non-Uint8Array (\".concat(bytes.constructor.name, \") stream chunk in an environment with a global \\\"Buffer\\\" defined, which this library assumes to be Node. Please report this error.\"));\n      }\n      // Browser\n      if (typeof TextDecoder !== 'undefined') {\n        if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n          (_a = this.textDecoder) !== null && _a !== void 0 ? _a : this.textDecoder = new TextDecoder('utf8');\n          return this.textDecoder.decode(bytes);\n        }\n        throw new Error(\"Unexpected: received non-Uint8Array/ArrayBuffer (\".concat(bytes.constructor.name, \") in a web platform. Please report this error.\"));\n      }\n      throw new Error(\"Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.\");\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (!this.buffer.length && !this.trailingCR) {\n        return [];\n      }\n      var lines = [this.buffer.join('')];\n      this.buffer = [];\n      this.trailingCR = false;\n      return lines;\n    }\n  }]);\n  return LineDecoder;\n}(); // prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', \"\\u2028\", \"\\u2029\"]);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\nfunction partition(str, delimiter) {\n  var index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  var reader = stream.getReader();\n  return _defineProperty({\n    next: function next() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return reader.read();\n            case 3:\n              result = _context3.sent;\n              if (result === null || result === void 0 ? void 0 : result.done) reader.releaseLock(); // release lock when stream becomes closed\n              return _context3.abrupt(\"return\", result);\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](0);\n              reader.releaseLock(); // release lock when stream becomes errored\n              throw _context3.t0;\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[0, 8]]);\n      }))();\n    },\n    return: function _return() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var cancelPromise;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              cancelPromise = reader.cancel();\n              reader.releaseLock();\n              _context4.next = 4;\n              return cancelPromise;\n            case 4:\n              return _context4.abrupt(\"return\", {\n                done: true,\n                value: undefined\n              });\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }))();\n    }\n  }, Symbol.asyncIterator, function () {\n    return this;\n  });\n}","map":{"version":3,"names":["Stream","_Symbol$asyncIterator","response","controller","_classCallCheck","decoder","SSEDecoder","_this","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","lineDecoder","iter","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","_iterator3","_step3","line","sse","_iterator4","_step4","_line","_sse","wrap","_callee$","_context","prev","next","body","abort","Error","LineDecoder","readableStreamAsyncIterable","_asyncIterator","_awaitAsyncGenerator","sent","done","value","_createForOfIteratorHelper","decode","s","n","t0","e","f","finish","t1","return","flush","t2","stop","_this2","_callee2","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_callee2$","_context2","iterMessages","abrupt","data","startsWith","JSON","parse","error","raw","name","Symbol","asyncIterator","endsWith","substring","length","event","join","chunks","push","partition","_partition2","_slicedToArray","_partition","_","fieldname","buffer","trailingCR","_createClass","key","text","slice","NEWLINE_CHARS","has","split","NEWLINE_REGEXP","trailingNewline","lines","concat","_toConsumableArray","pop","bytes","_a","Buffer","toString","Uint8Array","from","constructor","TextDecoder","ArrayBuffer","textDecoder","Set","str","delimiter","index","indexOf","stream","reader","read","result","_context3","releaseLock","_callee3","_return","_asyncToGenerator","_callee4","cancelPromise","_callee4$","_context4","cancel","undefined"],"sources":["E:\\Chat_bot_intership\\node_modules\\openai\\src\\streaming.ts"],"sourcesContent":["import type { Response } from './_shims/fetch.js';\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\ntype ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  private response: Response;\n  private decoder: SSEDecoder;\n\n  constructor(response: Response, controller: AbortController) {\n    this.response = response;\n    this.controller = controller;\n    this.decoder = new SSEDecoder();\n  }\n\n  private async *iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n    if (!this.response.body) {\n      this.controller.abort();\n      throw new Error(`Attempted to iterate over a response with no body`);\n    }\n    const lineDecoder = new LineDecoder();\n\n    const iter = readableStreamAsyncIterable<Bytes>(this.response.body);\n    for await (const chunk of iter) {\n      for (const line of lineDecoder.decode(chunk)) {\n        const sse = this.decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    for (const line of lineDecoder.flush()) {\n      const sse = this.decoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<Item, any, undefined> {\n    let done = false;\n    try {\n      for await (const sse of this.iterMessages()) {\n        if (done) continue;\n\n        if (sse.data.startsWith('[DONE]')) {\n          done = true;\n          continue;\n        }\n\n        if (sse.event === null) {\n          try {\n            yield JSON.parse(sse.data);\n          } catch (e) {\n            console.error(`Could not parse message into JSON:`, sse.data);\n            console.error(`From chunk:`, sse.raw);\n            throw e;\n          }\n        }\n      }\n      done = true;\n    } catch (e) {\n      // If the user calls `stream.controller.abort()`, we should exit without throwing.\n      if (e instanceof Error && e.name === 'AbortError') return;\n      throw e;\n    } finally {\n      // If the user `break`s, abort the ongoing request.\n      if (!done) this.controller.abort();\n    }\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new Error(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new Error(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new Error(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}